var documenterSearchIndex = {"docs":
[{"location":"#PDMPFlux","page":"Home","title":"PDMPFlux","text":"Documentation for PDMPFlux.\n\n\n\nusing PDMPFlux\n\nfunction ∇U(x::AbstractVector)\n    return x\nend\n\ndim = 10\nsampler = ForwardECMC(dim, ∇U)\n\nN_sk, N, xinit, vinit = 20_000, 5_000, zeros(dim), ones(dim)\nsamples = sample(sampler, N_sk, N, xinit, vinit, seed=2025)\n\njointplot(samples)\n\nusing PDMPFlux\n\nfunction U_banana(x::AbstractVector)\n  mean_x2 = (x[1]^2 - 1)\n  return -(- x[1]^2 + -(x[2] - mean_x2)^2 - x[3]^2) / 2\nend\n\ndim = 3\nsampler = ForwardECMCAD(dim, U_banana)\n\nN_sk, xinit, vinit, T_horizon = 20_000, zeros(dim), ones(dim), 1000.0\noutput = sample_skeleton(sampler, T_horizon, xinit, vinit, seed=2025)\n\nplot_traj(output, 50, plot_type=\"3D\")","category":"section"},{"location":"#PDMPFlux.ForwardECMCAD-Tuple{Int64, Function}","page":"Home","title":"PDMPFlux.ForwardECMCAD","text":"ForwardECMCAD(dim, U; kwargs...)\n\nCreate ForwardECMC sampler with automatic differentiation.\n\nArguments\n\ndim::Int: Dimension of the state space\nU::Function: Potential function\n\nKeywords\n\ngrid_size::Int=10: Number of grid points for upper bound\ntmax::Union{Float64, Int}=2.0: Maximum time horizon\nsigned_bound::Bool=true: Use signed bound strategy\nadaptive::Bool=true: Use adaptive time horizon\nAD_backend::String=\"Zygote\": Automatic differentiation backend\nran_p::Bool=true: Use random orthogonal refresh\nmix_p::Float64=0.5: Mixture probability for refreshment\n\nReturns\n\nForwardECMC: Configured sampler instance\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.RHMCAD-Tuple{Int64, Function}","page":"Home","title":"PDMPFlux.RHMCAD","text":"RHMCAD(dim::Int, U::Function; kwargs...)\n\nConvenience constructor that builds ∇U via the selected AD backend, like ZigZagAD etc.\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.anim_traj_-Tuple{PDMPHistory, Int64}","page":"Home","title":"PDMPFlux.anim_traj_","text":"A buffer function under development\nsupports faded color animation\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.plot_U_contour-Tuple{Any}","page":"Home","title":"PDMPFlux.plot_U_contour","text":"Create a contour plot of the potential function U (2D).\n\nArguments\n\nU: potential function taking a 2D vector\nx_range: range for the x-axis (default: range(-5, 5, length=100))\ny_range: range for the y-axis (default: range(-5, 5, length=100))\nlevels: number of contour levels (default: 20)\ncolor: color palette (default: :viridis)\nfill: whether to fill contours (default: true)\nshow_grid: show grid (default: false)\nshow_axis: show axis ticks/labels (default: false)\nshow_title: show title (default: false)\nxlabel: x-axis label (default: L\"x_1\")\nylabel: y-axis label (default: L\"x_2\")\nbackground: background (default: :transparent)\nlinewidth: contour line width (default: 1)\nfilename: output filename to save (default: nothing)\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.sample-Tuple{PDMPFlux.AbstractPDMP, Int64, Int64, Vector{Float64}, Vector{Float64}}","page":"Home","title":"PDMPFlux.sample","text":"sample(): draw samples from a `AbstractPDMP` sampler.\n\nThis is a thin wrapper that calls `sample_skeleton()` and then `sample_from_skeleton()`.\n\nArgs:\n    N_sk (Int): Number of skeleton points to generate.\n    N_samples (Int): Number of final samples to generate from the skeleton.\n    xinit (Array{Float64, 1}): Initial position.\n    vinit (Array{Float64, 1}): Initial velocity.\n    seed (Int): Seed for random number generation.\n    verbose (Bool, optional): Whether to print progress information. Defaults to true.\n\nReturns:\n    Array{Float64, 2}: Array of samples generated from the PDMP model.\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.sample_from_skeleton-Tuple{PDMPFlux.AbstractPDMP, Float64, PDMPHistory}","page":"Home","title":"PDMPFlux.sample_from_skeleton","text":"Sample along a skeleton and return a `Matrix{Float64}` whose rows store per-dimension time series.\n\nArgs:\n    dt (Float64): The time step.\n    output (PdmpOutput): The PDMP output containing the trajectory information.\n\nReturns:\n    Array{Float64, 2}: The sampled points from the PDMP trajectory skeleton.\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.sample_from_skeleton-Tuple{PDMPFlux.AbstractPDMP, Int64, PDMPHistory}","page":"Home","title":"PDMPFlux.sample_from_skeleton","text":"Sample along a skeleton and return a Matrix{Float64} whose rows store per-dimension time series.\n\nArgs:     N (Int): The number of samples to generate.     output (PdmpOutput): The PDMP output containing the trajectory information.\n\nReturns:     Array{Float64, 2}: The sampled points from the PDMP trajectory skeleton.\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.sample_skeleton-Tuple{PDMPFlux.AbstractPDMP, Float64, Vector{Float64}, Vector{Float64}}","page":"Home","title":"PDMPFlux.sample_skeleton","text":"sample_skeleton(sampler::AbstractPDMP, T::Float64, xinit, vinit; seed, verbose, init_capacity)\n\nTime-horizon variant: advance the PDMP up to time T (instead of generating n_sk events) and return the skeleton.\n\nSince the number of events is not known a priori, PDMPHistory is allocated with init_capacity and grown by doubling as needed (with copying).\nThe return value is forced to satisfy t[end] == T by adding one final point at t=T via deterministic flow (because sample_from_skeleton uses t[end] as the time scale).\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.sample_skeleton-Tuple{PDMPFlux.AbstractPDMP, Int64, Union{Float64, Int64}, Union{Float64, Int64}}","page":"Home","title":"PDMPFlux.sample_skeleton","text":"failsafe dispatch of sample_skeleton(), admitting scalar initial values, used mainly for 1d case.\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.sample_skeleton-Tuple{PDMPFlux.AbstractPDMP, Int64, Vector{Float64}, Vector{Float64}}","page":"Home","title":"PDMPFlux.sample_skeleton","text":"sample_skeleton(): generate a PDMP skeleton (event times/states) from a PDMP sampler.\n\nParameters:\n- n_sk (Int): The number of skeleton samples to generate.\n- xinit (Array{Float64, 1}): The initial position of the particles.\n- vinit (Array{Float64, 1}): The initial velocity of the particles.\n- seed (Int): The seed value for random number generation.\n- verbose (Bool): Whether to display progress bar during sampling. Default is true.\n\nReturns:\n- output: The output state of the sampling process.\n\n\n\n\n\n","category":"method"},{"location":"#PDMPFlux.PDMPState","page":"Home","title":"PDMPFlux.PDMPState","text":"PDMPState <: Any\n\nA state in the state space of an `AbstractPDMP`, implemented as a struct with the fields below.\n\nAttributes:\n    x (AbstractVector{T}): position\n    v (AbstractVector{T}): velocity\n    t (Float64): time\n    is_active (AbstractVector{Bool}): indicator for the freezing state. Used in the sampling loop for Sticky samplers.\n\n    upper_bound_func (Function): upper bound function\n    upper_bound (Union{Nothing, NamedTuple}): upper bound box\n\n    lambda_bar (Float64): upper bound for the Poisson process\n    exp_rv (Float64): exponential random variable for the Poisson process\n    \n    lambda_t (Float64): rate at the current time\n    horizon (Float64): horizon\n    tp (Float64): time to the next event\n    ts (Float64): time spent\n    tt (Vector{Float64}): remaining frozen time for each coordinate, with dimension `dim`\n    ar (Float64): acceptance rate for the thinning\n\n    adaptive (Bool): adaptive indicator\n    accept (Bool): accept indicator for the thinning\n    stick_or_thaw_event (Bool): indicator for the sticking or thawing event\n    \n    errored_bound (Int): count of the number of errors in the upper bound\n    rejected (Int): count of the number of rejections in the thinning\n    hitting_horizon (Int): count of the number of hits of the horizon\n    \nNote:\n    Keep `flow/∇U/rate/velocity_jump/rng` on the sampler side, and keep `PDMPState` focused on\n    the evolving state variables `(x, v, t, ...)`.\n\n\n\n\n\n","category":"type"},{"location":"#PDMPFlux.RHMC","page":"Home","title":"PDMPFlux.RHMC","text":"RHMC(dim::Int, ∇U;\n     mean_duration=nothing,\n     refresh_rate=1.0,\n     phi=pi/2,\n     step_size=0.05,\n     tmax=10.0,\n     adaptive=false,\n     AD_backend=\"FiniteDiff\")\n\nRandomized Hamiltonian Monte Carlo (RHMC) sampler (Bou-Rabee & Sanz-Serna, 2017) as a PDMP.\n\nBetween events it follows Hamiltonian dynamics\n\nẋ = v,    v̇ = -∇U(x)\n\nand at Poisson event times (rate refresh_rate = 1/mean_duration) it refreshes momentum via\n\nv ← cos(phi) v + sin(phi) ξ,   ξ ~ N(0, I)\n\nNotes:\n\nThis implementation uses a velocity-Verlet integrator with step size step_size for the flow.\nIt is rejection-free in the exact-flow limit; with a finite step_size this is an approximation.\n\n\n\n\n\n","category":"type"},{"location":"#PDMPFlux.SpeedUpZigZag","page":"Home","title":"PDMPFlux.SpeedUpZigZag","text":"SpeedUpZigZag(dim::Int, ∇U::Function; grid_size::Int=10, tmax::Float64=1.0, \n    vectorized_bound::Bool=true, signed_bound::Bool=true, adaptive::Bool=true, kwargs...)\n\narguments for constructor\n\ndim::Int: dimension of the state space\n∇U::Function: gradient of the potential energy function\ngrid_size::Int: number of grid points used for upper-bound discretization (default: 10)\ntmax::Float64: bound horizon (default: 1.0). If set to 0, tmax is chosen adaptively.\nvectorized_bound::Bool: whether to use a vectorized bound strategy (default: true)\nsigned_bound::Bool: whether to use signed-rate bound strategies (default: true)\nadaptive::Bool: whether to adapt the horizon during sampling (default: true)\nkwargs...: additional keyword arguments\n\nattributes of a ZigZag construct\n\ndim::Int: dimension of the state space\nrefresh_rate::Float64: refresh rate\n∇U::Function: gradient of the potential\ngrid_size::Int: number of grid points used for upper-bound discretization\ntmax::Float64: bound horizon\nadaptive::Bool: whether to adapt the horizon during sampling\nvectorized_bound::Bool: whether a vectorized bound strategy is used\nsigned_bound::Bool: whether signed-rate strategies are used\nflow::Function: deterministic flow / integrator\nrate: scalar (unsigned) event rate\nrate_vect: vectorized (unsigned) event rate\nsigned_rate: scalar signed event rate (if used)\nsigned_rate_vect: vectorized signed event rate (if used)\nvelocity_jump::Function: velocity update at events\nstate: sampler state\n\n\n\n\n\n","category":"type"},{"location":"#PDMPFlux.StickyZigZag","page":"Home","title":"PDMPFlux.StickyZigZag","text":"StickyZigZag(dim::Int, ∇U::Function; grid_size::Int=10, tmax::Float64=1.0, \n    vectorized_bound::Bool=true, signed_bound::Bool=true, adaptive::Bool=true, kwargs...)\n\narguments for constructor\n\ndim::Int: dimension of the parameter space\n∇U::Function: gradient of the potential function (= negative log-likelihood function)\nκ::Vector{Float64}: thawing rate defined from prior inclusion probability. default is fill(0.5, dim).\ngrid_size::Int: number of the grid points for discretization of the parameter space. default is 10.\ntmax::Float64: bound horizon (default: 1.0). If set to 0, tmax is chosen adaptively.\nvectorized_bound::Bool: whether to use a vectorized bound strategy (default: true)\nsigned_bound::Bool: whether to use signed-rate bound strategies (default: true)\nadaptive::Bool: whether to adapt the horizon during sampling (default: true)\nkwargs...: additional keyword arguments\n\nattributes of a ZigZag construct\n\ndim::Int: dimension of the state space\nrefresh_rate::Float64: refresh rate\n∇U::Function: gradient of the potential\ngrid_size::Int: number of grid points used for upper-bound discretization\ntmax::Float64: bound horizon\nadaptive::Bool: whether to adapt the horizon during sampling\nvectorized_bound::Bool: whether a vectorized bound strategy is used\nsigned_bound::Bool: whether signed-rate strategies are used\nflow::Function: deterministic flow / integrator\nrate: scalar (unsigned) event rate\nrate_vect: vectorized (unsigned) event rate\nsigned_rate: scalar signed event rate (if used)\nsigned_rate_vect: vectorized signed event rate (if used)\nvelocity_jump::Function: velocity update at events\nstate: sampler state\n\n\n\n\n\n","category":"type"},{"location":"#PDMPFlux.ZigZag","page":"Home","title":"PDMPFlux.ZigZag","text":"ZigZag(dim::Int, ∇U::Function; grid_size::Int=10, tmax::Float64=1.0, \n    vectorized_bound::Bool=true, signed_bound::Bool=true, adaptive::Bool=true, kwargs...)\n\narguments for constructor\n\ndim::Int: dimension of the state space\n∇U::Function: gradient of the potential energy function\ngrid_size::Int: number of grid points used for upper-bound discretization (default: 10)\ntmax::Float64: bound horizon (default: 1.0). If set to 0, tmax is chosen adaptively.\nvectorized_bound::Bool: whether to use a vectorized bound strategy (default: true)\nsigned_bound::Bool: whether to use signed-rate bound strategies (default: true)\nadaptive::Bool: whether to adapt the horizon during sampling (default: true)\nkwargs...: additional keyword arguments\n\nattributes of a ZigZag construct\n\ndim::Int: dimension of the state space\nrefresh_rate::Float64: refresh rate (currently unused for ZigZag)\n∇U::Function: gradient of the potential\ngrid_size::Int: number of grid points used for upper-bound discretization\ntmax::Float64: bound horizon\nadaptive::Bool: whether to adapt the horizon during sampling\nvectorized_bound::Bool: whether a vectorized bound strategy is used\nsigned_bound::Bool: whether signed-rate strategies are used\nflow::Function: deterministic flow / integrator\nrate: scalar (unsigned) event rate\nrate_vect: vectorized (unsigned) event rate\nsigned_rate: scalar signed event rate (if used)\nsigned_rate_vect: vectorized signed event rate (if used)\nvelocity_jump::Function: velocity update at events\nstate: sampler state\n\n\n\n\n\n","category":"type"},{"location":"tutorials/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"PDMPFlux.jl provides a fast and efficient implementation of Piecewise Deterministic Markov Process (PDMP) samplers. This guide will walk you through the basic usage of PDMPFlux.jl.","category":"section"},{"location":"tutorials/quickstart/#Installation","page":"Quickstart Guide","title":"Installation","text":"Julia 1.11 or higher is required. Install using Julia's package manager:\n\nusing Pkg\nPkg.add(\"PDMPFlux\")","category":"section"},{"location":"tutorials/quickstart/#Basic-Usage-Examples","page":"Quickstart Guide","title":"Basic Usage Examples","text":"","category":"section"},{"location":"tutorials/quickstart/#1.-Sampling-from-a-Standard-Gaussian-Distribution","page":"Quickstart Guide","title":"1. Sampling from a Standard Gaussian Distribution","text":"Let's start with the simplest example - sampling from a standard Gaussian distribution using the Zig-Zag sampler:\n\nusing PDMPFlux\n\n# Define the negative log density function\nfunction U_Gauss(x::Vector)\n    return sum(x.^2) / 2\nend\n\n# Set up the sampler\ndim = 10\nsampler = ZigZagAD(dim, U_Gauss)\n\n# Run sampling\nN_sk, N, xinit, vinit = 1_000_000, 1_000_000, zeros(dim), ones(dim)\nsamples = sample(sampler, N_sk, N, xinit, vinit, seed=2024)\n\n# Visualize results\njointplot(samples)","category":"section"},{"location":"tutorials/quickstart/#2.-Sampling-from-a-Banana-Distribution","page":"Quickstart Guide","title":"2. Sampling from a Banana Distribution","text":"For a more complex example, let's try sampling from a Banana distribution (a non-linear distribution):\n\nusing PDMPFlux\nusing Zygote\n\n# Banana distribution negative log density function\nfunction U_banana(x::Vector)\n    mean_x2 = (x[1]^2 - 1)\n    return -(- x[1]^2 + -(x[2] - mean_x2)^2) / 2\nend\n\n# Manually provide gradient\nfunction ∇U_banana(x::Vector)\n    mean_x2 = (x[1]^2 - 1)\n    return -(- x[1] + -(x[2] - mean_x2) - sum(x[3:end]))\nend\n\ndim = 50\nxinit = ones(dim)\nvinit = ones(dim)\ngrid_size = 0  # use constant bounds\n\n# Create and run sampler\nsampler = ZigZag(dim, ∇U_banana, grid_size=grid_size)\noutput = sample_skeleton(sampler, 1_000_000, xinit, vinit)\nsamples = sample_from_skeleton(sampler, 1_000_000, output)\n\n# Visualize trajectory\nplot_traj(output, 10000)\njointplot(samples)","category":"section"},{"location":"tutorials/quickstart/#Available-Samplers","page":"Quickstart Guide","title":"Available Samplers","text":"PDMPFlux.jl provides the following samplers:","category":"section"},{"location":"tutorials/quickstart/#Zig-Zag-Sampler","page":"Quickstart Guide","title":"Zig-Zag Sampler","text":"ZigZagAD: Uses automatic differentiation\nZigZag: Manual gradient provision","category":"section"},{"location":"tutorials/quickstart/#Bouncy-Particle-Sampler-(BPS)","page":"Quickstart Guide","title":"Bouncy Particle Sampler (BPS)","text":"BPSAD: Uses automatic differentiation\nBPS: Manual gradient provision","category":"section"},{"location":"tutorials/quickstart/#Forward-Event-Chain-Monte-Carlo-(Forward-ECMC)","page":"Quickstart Guide","title":"Forward Event Chain Monte Carlo (Forward ECMC)","text":"ForwardECMCAD: Uses automatic differentiation\nForwardECMC: Manual gradient provision","category":"section"},{"location":"tutorials/quickstart/#Boomerang-Sampler","page":"Quickstart Guide","title":"Boomerang Sampler","text":"BoomerangAD: Uses automatic differentiation\nBoomerang: Manual gradient provision","category":"section"},{"location":"tutorials/quickstart/#Speed-Up-Zig-Zag-(SUZZ)","page":"Quickstart Guide","title":"Speed Up Zig-Zag (SUZZ)","text":"SpeedUpZigZagAD: Uses automatic differentiation\nSpeedUpZigZag: Manual gradient provision","category":"section"},{"location":"tutorials/quickstart/#Sticky-Zig-Zag-Sampler","page":"Quickstart Guide","title":"Sticky Zig-Zag Sampler","text":"StickyZigZagAD: Uses automatic differentiation\nStickyZigZag: Manual gradient provision","category":"section"},{"location":"tutorials/quickstart/#Visualization-and-Diagnostics","page":"Quickstart Guide","title":"Visualization and Diagnostics","text":"","category":"section"},{"location":"tutorials/quickstart/#Trajectory-Visualization","page":"Quickstart Guide","title":"Trajectory Visualization","text":"# Plot 2D trajectory\nplot_traj(output, 10000)\n\n# Plot 3D trajectory\nplot_traj(output, 1000, plot_type=\"3D\")\n\n# Create animation\nanim_traj(output, 1000; filename=\"trajectory.gif\")","category":"section"},{"location":"tutorials/quickstart/#Diagnostic-Functions","page":"Quickstart Guide","title":"Diagnostic Functions","text":"# Sampler diagnostics\ndiagnostic(output)","category":"section"},{"location":"tutorials/quickstart/#Sample-Visualization","page":"Quickstart Guide","title":"Sample Visualization","text":"# Joint distribution plot\njointplot(samples)\n\n# Marginal distribution plot\nmarginalplot(samples)","category":"section"},{"location":"tutorials/quickstart/#Advanced-Usage","page":"Quickstart Guide","title":"Advanced Usage","text":"","category":"section"},{"location":"tutorials/quickstart/#Custom-Gradient-Provision","page":"Quickstart Guide","title":"Custom Gradient Provision","text":"using ForwardDiff\n\n# Gradient calculation using ForwardDiff\n∇U(x::Vector) = ForwardDiff.gradient(U, x)\nsampler = ZigZag(dim, ∇U, grid_size=grid_size)","category":"section"},{"location":"tutorials/quickstart/#Using-Different-AD-Backends","page":"Quickstart Guide","title":"Using Different AD Backends","text":"using Zygote\n\n# Gradient calculation using Zygote\n∇U(x::Vector) = gradient(U, x)[1]\nsampler = ZigZag(dim, ∇U, grid_size=grid_size)","category":"section"},{"location":"tutorials/quickstart/#Next-Steps","page":"Quickstart Guide","title":"Next Steps","text":"Check the full documentation for more detailed information\nExplore more complex examples in the examples directory\nUnderstand the characteristics of each sampler and choose the appropriate one for your problem\n\nPDMPFlux.jl is a powerful tool that enables efficient sampling in high dimensions. Start with simple examples and gradually work your way up to more complex problems.","category":"section"}]
}
